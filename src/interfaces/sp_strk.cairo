use starknet::ContractAddress;

// Structure to hold unlock request details
#[derive(Copy, Drop, Serde, PartialEq, Debug, starknet::Store)]
pub struct UnlockRequest {
    // Amount of spSTRK shares to unlock
    pub sp_strk_amount: u256,
    // Minimum STRK tokens expected after unlock
    pub strk_amount: u256,
    // Unlock time in UNIX timestamp
    pub unlock_time: u64,
    // Expiry time in UNIX timestamp
    pub expiry_time: u64,
}

// ========== NEW: NFT-based withdrawal functions ==========
#[starknet::interface]
pub trait IWithdrawalNFT<TContractState> {
    /// Claim withdrawal using NFT
    fn claim_withdrawal_nft(ref self: TContractState, token_id: u256);
    
    /// Cancel withdrawal and get spSTRK back
    fn cancel_withdrawal_nft(ref self: TContractState, token_id: u256);
    
    /// Claim expired withdrawal (returns spSTRK)
    fn claim_expired_nft(ref self: TContractState, token_id: u256);
    
    /// Get withdrawal NFT data (request, is_ready, is_expired)
    fn get_withdrawal_nft_data(
        self: @TContractState, 
        token_id: u256
    ) -> (UnlockRequest, bool, bool);
}

#[starknet::interface]
pub trait IspSTRK<TContractState> {
    // ====================================
    // User functions
    // ====================================

    ///  Stake STRK tokens to receive spSTRK shares
    fn stake(ref self: TContractState, strk_amount: u256, min_sp_strk_out: u256) -> u256;
    ///  Request to unlock spSTRK shares for STRK tokens
    fn request_unlock(ref self: TContractState, sp_strk_amount: u256, min_strk_out: u256) -> u256;
    ///  Claim unlocked STRK tokens after the unlock period
    fn claim_unlock(ref self: TContractState, request_index: u256);
    ///  Cancel an existing unlock request
    fn cancel_unlock(ref self: TContractState, request_index: u256);

    fn claim_expired(ref self: TContractState, request_index: u256);

    fn get_unlock_request_count(self: @TContractState, user: ContractAddress) -> u256;

    ///  Get the unlock request details for a user
    fn get_unlock_request(
        self: @TContractState, user: ContractAddress, request_index: u256,
    ) -> (UnlockRequest, u256, bool, bool);
    ///  Get the current exchange rate of STRK to spSTRK
    fn get_exchange_rate(self: @TContractState) -> u256;
    ///  Preview the amount of spSTRK shares received for a given STRK amount
    fn preview_stake(self: @TContractState, strk_amount: u256) -> u256;
    ///  Preview the amount of STRK tokens received for a given spSTRK amount
    fn preview_unlock(self: @TContractState, sp_strk_amount: u256) -> u256;
    ///  Get overall contract statistics
    fn get_stats(self: @TContractState) -> (u256, u256, u256, u256, u256, u256, u16, u16);

    fn get_validator_unbonding_status(self: @TContractState) -> (u256, u64, u64, bool);

    // ====================================
    // Admin functions
    // ====================================

    /// Deposit STRK tokens
    fn admin_deposit(ref self: TContractState, strk_amount: u256);
    /// Withdraw STRK tokens
    fn admin_withdraw(ref self: TContractState, strk_amount: u256);
    /// Add rewards to the staking pool
    fn add_rewards(ref self: TContractState, strk_amount: u256);

    fn collect_all_fees(ref self: TContractState);
    /// Collect accumulated DAO fees
    fn collect_dao_fees(ref self: TContractState);
    /// Collect accumulated developer fees
    fn collect_dev_fees(ref self: TContractState);
    /// Set the fee structure
    fn set_fees(ref self: TContractState, dao_fee_bps: u16, dev_fee_bps: u16);
    /// Set the minimum stake amount
    fn set_min_stake_amount(ref self: TContractState, new_amount: u256);
    /// Set the unlock period
    fn set_unlock_period(ref self: TContractState, new_period: u64);
    /// Set the claim window
    fn set_claim_window(ref self: TContractState, new_window: u64);
    /// Pause the contract
    fn pause(ref self: TContractState);
    /// Unpause the contract
    fn unpause(ref self: TContractState);

    fn set_withdrawal_queue_nft(ref self: TContractState, nft_address: ContractAddress);

    /// Claim rewards from validator
    fn claim_validator_rewards(ref self: TContractState);
    /// Start unbonding from validator
    fn unstake_from_validator(ref self: TContractState, amount: u256);
    /// Complete unbonding from validator (after 7 days)
    fn complete_validator_unstaking(ref self: TContractState);
}

// ========== Noir Verifier Interface ==========
#[starknet::interface]
pub trait IUltraStarknetHonkVerifier<TContractState> {
    /// Verify a Noir proof generated by the ultra_honk proving system
    /// Returns Some(public_inputs) if proof is valid, None otherwise
    fn verify_ultra_starknet_honk_proof(
        self: @TContractState,
        full_proof_with_hints: Span<felt252>,
    ) -> Option<Span<u256>>;
}

// ========== Privacy Layer Interface ==========
#[starknet::interface]
pub trait IPrivacyWithdrawal<TContractState> {
    /// Create a private deposit commitment
    /// The commitment should be pre-computed off-chain using Noir's Poseidon hash
    /// commitment = poseidon(poseidon(poseidon(secret, shares), deposit_time), blinding)
    fn create_commitment(
        ref self: TContractState,
        sp_strk_amount: u256,
        commitment: u256,     // Pre-computed commitment hash (u256 to hold full BN254 field element)
        blinding: felt252     // Still needed for future use
    ) -> u256;
    
    /// Check if a nullifier has been used
    fn is_nullifier_used(self: @TContractState, nullifier: u256) -> bool;
    
    /// Get the unlock time for a private commitment (0 if not requested)
    fn get_private_unlock_time(self: @TContractState, commitment: u256) -> u64;
    
    /// Get the current Merkle root
    fn get_merkle_root(self: @TContractState) -> u256;

    /// Step 1: Mark deposit intent (user transfers STRK)
    fn mark_deposit_intent(ref self: TContractState, amount: u256);

    /// Step 2: Create private commitment with ZK proof
    fn create_private_commitment(
        ref self: TContractState,
        proof: Span<felt252>,
        commitment: u256,
        amount: u256,
        shares: u256
    );

    /// Stake from Zcash bridge with private commitment
    /// Only callable by authorized bridge contract
    fn stake_from_bridge_private(
        ref self: TContractState,
        strk_amount: u256,
        commitment: u256,
        blinding: felt252
    ) -> u256;

    /// Claim spSTRK tokens - exits privacy for liquidity (INSTANT)
    /// TRUE PRIVACY: Only nullifier is revealed, commitment stays hidden
    fn claim_spSTRK(
        ref self: TContractState,
        proof: Span<felt252>,
        nullifier: u256,
        recipient: ContractAddress
    );

    /// Request private unlock - starts time lock for private STRK withdrawal
    /// Uses nullifier_hash to track without revealing commitment or nullifier
    fn request_private_unlock(
        ref self: TContractState,
        proof: Span<felt252>,
        nullifier_hash: u256
    );

    /// Complete private withdrawal after unlock period
    /// TRUE PRIVACY: Only nullifier is revealed, commitment stays hidden
    fn complete_private_withdraw(
        ref self: TContractState,
        proof: Span<felt252>,
        nullifier: u256,
        recipient: ContractAddress
    );
}

// ========== Privacy Admin Interface ==========
#[starknet::interface]
pub trait IPrivacyAdmin<TContractState> {
    /// Set the unlock verifier contract address (for private withdrawals)
    fn set_unlock_verifier(ref self: TContractState, verifier: ContractAddress);
    
    /// Set the deposit verifier contract address (for private deposits)
    fn set_deposit_verifier(ref self: TContractState, verifier: ContractAddress);
    
    /// Enable privacy features
    fn enable_privacy(ref self: TContractState);
    
    /// Disable privacy features
    fn disable_privacy(ref self: TContractState);

    /// Set the Zcash bridge contract address
    fn set_zcash_bridge(ref self: TContractState, bridge: ContractAddress);
    
    /// Get privacy status
    fn is_privacy_enabled(self: @TContractState) -> bool;
    
    /// Get unlock verifier address
    fn get_unlock_verifier(self: @TContractState) -> ContractAddress;
    
    /// Get deposit verifier address
    fn get_deposit_verifier(self: @TContractState) -> ContractAddress;

    /// Submit a Merkle root from the indexer
    /// The indexer computes the Merkle tree off-chain using BN254 Poseidon
    /// (which matches the Noir circuit) and submits roots here.
    /// Only callable by owner (can be extended to multiple trusted indexers).
    fn submit_merkle_root(ref self: TContractState, root: u256);
}

// Error messages used in the contract
pub mod Errors {
    pub const BELOW_MINIMUM_STAKE: felt252 = 'Below minimum stake';
    pub const FEES_TOO_HIGH: felt252 = 'Fees too high';
    pub const INSUFFICIENT_SHARES: felt252 = 'Insufficient shares';
    pub const INSUFFICIENT_BALANCE: felt252 = 'Insufficient balance';
    pub const INSUFFICIENT_STARK: felt252 = 'Insufficient STRK balance';
    pub const SLIPPAGE_EXCEEDED: felt252 = 'Slippage exceeded';
    pub const TRANSFER_FAILED: felt252 = 'STRK transfer failed';
    pub const INVALID_AMOUNT: felt252 = 'Invalid amount';
    pub const INVALID_STRK_AMOUNT: felt252 = 'Invalid STRK amount';
    pub const BELOW_MIN: felt252 = 'Value below minimum';
    pub const ABOVE_MAX: felt252 = 'Value above maximum';
    pub const NO_SHARES_EXIST: felt252 = 'No shares exist';
    pub const NO_FEES_TO_COLLECT: felt252 = 'No fees to collect';
    pub const REQUEST_PENDING: felt252 = 'Unlock request already pending';
    pub const REQUEST_EXPIRED: felt252 = 'Unlock request expired';
    pub const REQUEST_NOT_EXIST: felt252 = 'Unlock request does not exist';
    pub const REQUEST_NOT_READY: felt252 = 'Unlock request not ready';
    pub const TOO_MANY_REQUESTS: felt252 = 'Too many pending requests';
    pub const INVALID_REQUEST_INDEX: felt252 = 'Invalid request index';
}
